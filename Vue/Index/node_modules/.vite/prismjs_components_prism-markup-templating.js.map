{
  "version": 3,
  "sources": ["../prismjs/components/prism-markup-templating.js", "dep:prismjs_components_prism-markup-templating"],
  "sourcesContent": ["(function (Prism) {\n\n\t/**\n\t * Returns the placeholder for the given language id and index.\n\t *\n\t * @param {string} language\n\t * @param {string|number} index\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(language, index) {\n\t\treturn '___' + language.toUpperCase() + index + '___';\n\t}\n\n\tObject.defineProperties(Prism.languages['markup-templating'] = {}, {\n\t\tbuildPlaceholders: {\n\t\t\t/**\n\t\t\t * Tokenize all inline templating expressions matching `placeholderPattern`.\n\t\t\t *\n\t\t\t * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n\t\t\t * `true` will be replaced.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `before-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n\t\t\t * @param {(match: string) => boolean} [replaceFilter]\n\t\t\t */\n\t\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\t\tif (env.language !== language) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar tokenStack = env.tokenStack = [];\n\n\t\t\t\tenv.code = env.code.replace(placeholderPattern, function (match) {\n\t\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = tokenStack.length;\n\t\t\t\t\tvar placeholder;\n\n\t\t\t\t\t// Check for existing strings\n\t\t\t\t\twhile (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a sparse array\n\t\t\t\t\ttokenStack[i] = match;\n\n\t\t\t\t\treturn placeholder;\n\t\t\t\t});\n\n\t\t\t\t// Switch the grammar to markup\n\t\t\t\tenv.grammar = Prism.languages.markup;\n\t\t\t}\n\t\t},\n\t\ttokenizePlaceholders: {\n\t\t\t/**\n\t\t\t * Replace placeholders with proper tokens after tokenizing.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `after-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t */\n\t\t\tvalue: function (env, language) {\n\t\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Switch the grammar back\n\t\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\t\tvar j = 0;\n\t\t\t\tvar keys = Object.keys(env.tokenStack);\n\n\t\t\t\tfunction walkTokens(tokens) {\n\t\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\t\t// all placeholders are replaced already\n\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\t\t\t\t\t\t\tvar placeholder = getPlaceholder(language, k);\n\n\t\t\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t\t++j;\n\n\t\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n\t\t\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([before]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([after]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (token.content /* && typeof token.content !== 'string' */) {\n\t\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t}\n\n\t\t\t\twalkTokens(env.tokens);\n\t\t\t}\n\t\t}\n\t});\n\n}(Prism));\n", "export default require(\"./node_modules/prismjs/components/prism-markup-templating.js\");"],
  "mappings": ";;;;;AAAA;AAAA;AAAA,IAAC,UAAU,QAAO;AASjB,8BAAwB,UAAU,OAAO;AACxC,eAAO,QAAQ,SAAS,gBAAgB,QAAQ;AAAA;AAGjD,aAAO,iBAAiB,OAAM,UAAU,uBAAuB,IAAI;AAAA,QAClE,mBAAmB;AAAA,UAYlB,OAAO,SAAU,KAAK,UAAU,oBAAoB,eAAe;AAClE,gBAAI,IAAI,aAAa,UAAU;AAC9B;AAAA;AAGD,gBAAI,aAAa,IAAI,aAAa;AAElC,gBAAI,OAAO,IAAI,KAAK,QAAQ,oBAAoB,SAAU,OAAO;AAChE,kBAAI,OAAO,kBAAkB,cAAc,CAAC,cAAc,QAAQ;AACjE,uBAAO;AAAA;AAER,kBAAI,IAAI,WAAW;AACnB,kBAAI;AAGJ,qBAAO,IAAI,KAAK,QAAQ,cAAc,eAAe,UAAU,QAAQ,IAAI;AAC1E,kBAAE;AAAA;AAIH,yBAAW,KAAK;AAEhB,qBAAO;AAAA;AAIR,gBAAI,UAAU,OAAM,UAAU;AAAA;AAAA;AAAA,QAGhC,sBAAsB;AAAA,UAOrB,OAAO,SAAU,KAAK,UAAU;AAC/B,gBAAI,IAAI,aAAa,YAAY,CAAC,IAAI,YAAY;AACjD;AAAA;AAID,gBAAI,UAAU,OAAM,UAAU;AAE9B,gBAAI,IAAI;AACR,gBAAI,OAAO,OAAO,KAAK,IAAI;AAE3B,gCAAoB,QAAQ;AAC3B,uBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AAEvC,oBAAI,KAAK,KAAK,QAAQ;AACrB;AAAA;AAGD,oBAAI,QAAQ,OAAO;AACnB,oBAAI,OAAO,UAAU,YAAa,MAAM,WAAW,OAAO,MAAM,YAAY,UAAW;AACtF,sBAAI,IAAI,KAAK;AACb,sBAAI,IAAI,IAAI,WAAW;AACvB,sBAAI,IAAI,OAAO,UAAU,WAAW,QAAQ,MAAM;AAClD,sBAAI,cAAc,eAAe,UAAU;AAE3C,sBAAI,QAAQ,EAAE,QAAQ;AACtB,sBAAI,QAAQ,IAAI;AACf,sBAAE;AAEF,wBAAI,SAAS,EAAE,UAAU,GAAG;AAC5B,wBAAI,SAAS,IAAI,OAAM,MAAM,UAAU,OAAM,SAAS,GAAG,IAAI,UAAU,cAAc,UAAU;AAC/F,wBAAI,QAAQ,EAAE,UAAU,QAAQ,YAAY;AAE5C,wBAAI,cAAc;AAClB,wBAAI,QAAQ;AACX,kCAAY,KAAK,MAAM,aAAa,WAAW,CAAC;AAAA;AAEjD,gCAAY,KAAK;AACjB,wBAAI,OAAO;AACV,kCAAY,KAAK,MAAM,aAAa,WAAW,CAAC;AAAA;AAGjD,wBAAI,OAAO,UAAU,UAAU;AAC9B,6BAAO,OAAO,MAAM,QAAQ,CAAC,GAAG,GAAG,OAAO;AAAA,2BACpC;AACN,4BAAM,UAAU;AAAA;AAAA;AAAA,2BAGR,MAAM,SAAoD;AACpE,6BAAW,MAAM;AAAA;AAAA;AAInB,qBAAO;AAAA;AAGR,uBAAW,IAAI;AAAA;AAAA;AAAA;AAAA,OAKjB;AAAA;AAAA;;;AC3HF,IAAO,qDAAQ;",
  "names": []
}
